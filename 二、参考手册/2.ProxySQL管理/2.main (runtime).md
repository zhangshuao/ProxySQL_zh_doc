# main (runtime表定义)

## 介绍

    ProxySQL的管理员将配置存储在表中。
    如果您使用admin-admin_credentials连接到Admin，您应该能够看到如下所示的配置和runtime运行时表列表。

    表的确切列表可能因使用的版本以及ProxySQL的某些模块是否在运行而有所不同。
    Admin> SHOW TABLES FROM main;
    +----------------------------------------------------+
    | tables                                             |
    +----------------------------------------------------+
    | clickhouse_users                                   |
    | debug_filters                                      |
    | debug_levels                                       |
    | global_variables                                   |
    | mysql_aws_aurora_hostgroups                        |
    | mysql_collations                                   |
    | mysql_firewall_whitelist_rules                     |
    | mysql_firewall_whitelist_sqli_fingerprints         |
    | mysql_firewall_whitelist_users                     |
    | mysql_galera_hostgroups                            |
    | mysql_group_replication_hostgroups                 |
    | mysql_query_rules                                  |
    | mysql_query_rules_fast_routing                     |
    | mysql_replication_hostgroups                       |
    | mysql_servers                                      |
    | mysql_users                                        |
    | proxysql_servers                                   |
    | restapi_routes                                     |
    | runtime_checksums_values                           |
    | runtime_clickhouse_users                           |
    | runtime_global_variables                           |
    | runtime_mysql_aws_aurora_hostgroups                |
    | runtime_mysql_firewall_whitelist_rules             |
    | runtime_mysql_firewall_whitelist_sqli_fingerprints |
    | runtime_mysql_firewall_whitelist_users             |
    | runtime_mysql_galera_hostgroups                    |
    | runtime_mysql_group_replication_hostgroups         |
    | runtime_mysql_query_rules                          |
    | runtime_mysql_query_rules_fast_routing             |
    | runtime_mysql_replication_hostgroups               |
    | runtime_mysql_servers                              |
    | runtime_mysql_users                                |
    | runtime_proxysql_servers                           |
    | runtime_restapi_routes                             |
    | runtime_scheduler                                  |
    | scheduler                                          |
    +----------------------------------------------------+
    36 rows in set (0,03 sec)

    在以下各节中，您将看到所有配置表的详细说明。


# Key配置表

    表名	                                    配置
    mysql_users	                            前端和后端mysql用户
    mysql_servers	                        后端mysql服务器
    mysql_galera_hostgroups             	使用galera复制的mysql群集
    mysql_group_replication_hostgroups	    使用组复制的mysql群集
    mysql_replication_hostgroups	        mysql复制群集，服务器处于RW或RO模式
    mysql_query_rules	                    mysql流量的查询规则
    mysql_query_rules_fast_routing	        专门用于路由的mysql流量查询规则
    global_variables	                    所有变量
    scheduler	                            可以执行的调度器任务
    mysql_collations	                    已知mysql字符集和排序规则
    proxysql_servers	                    proxysql群集中的核心节点列表
    restapi_routes	                        RESTAPI endpoints端点

#### mysql_servers

    mysql_servers表定义了所有属于mysql服务器或使用mysql协议的后端服务器（例如，另一个ProxySQL实例）。

    服务器分组为hostgroups，其中hostgroups是具有相同逻辑功能的一组服务器。

    表mysql_servers定义如下：

    Admin> SHOW CREATE TABLE mysql_servers\G
    *************************** 1. row ***************************
           table: mysql_servers
    Create Table: CREATE TABLE mysql_servers (
        hostgroup_id INT CHECK (hostgroup_id>=0) NOT NULL DEFAULT 0,
        hostname VARCHAR NOT NULL,
        port INT CHECK (port >= 0 AND port <= 65535) NOT NULL DEFAULT 3306,
        gtid_port INT CHECK ((gtid_port <> port OR gtid_port=0) AND gtid_port >= 0 AND gtid_port <= 65535) NOT NULL DEFAULT 0,
        status VARCHAR CHECK (UPPER(status) IN ('ONLINE','SHUNNED','OFFLINE_SOFT', 'OFFLINE_HARD')) NOT NULL DEFAULT 'ONLINE',
        weight INT CHECK (weight >= 0 AND weight <=10000000) NOT NULL DEFAULT 1,
        compression INT CHECK (compression IN(0,1)) NOT NULL DEFAULT 0,
        max_connections INT CHECK (max_connections >=0) NOT NULL DEFAULT 1000,
        max_replication_lag INT CHECK (max_replication_lag >= 0 AND max_replication_lag <= 126144000) NOT NULL DEFAULT 0,
        use_ssl INT CHECK (use_ssl IN(0,1)) NOT NULL DEFAULT 0,
        max_latency_ms INT UNSIGNED CHECK (max_latency_ms>=0) NOT NULL DEFAULT 0,
        comment VARCHAR NOT NULL DEFAULT '',
        PRIMARY KEY (hostgroup_id, hostname, port) )
    1 row in set (0.01 sec)

    字段具有以下语义：

    * hostgroup_id: 包含此后端服务器的主机组。请注意，同一实例可以是多个主机组的一部分
    * hostname, port: 可以到达后端服务器的TCP端点。如果端口为0，主机名中的值将解释为Unix套接字文件
    * gtid_port: ProxySQL Binlog Reader侦听gtid跟踪的后端服务器端口
    * status: 后端的配置状态。这并不表示当前状态，而是已配置的状态：
        * ONLINE – 后端服务器已完全运行
        * SHUNNED – 后端服务器暂时停止使用，原因可能是在太短的时间内出现了太多的连接错误，或者复制延迟超过了允许的阈值
        * OFFLINE_SOFT – 当服务器处于OFFLINE_SOFT模式时，不会创建指向该服务器的新连接，而保留现有连接，直到它们返回到连接池或销毁。
                         换句话说，连接将一直保持使用状态，直到再次启用多路复用，例如事务完成时。这使得只要多路复用是有效的，就可以优雅地分离后端
        * OFFLINE_HARD – 当服务器处于OFFLINE_HARD模式时，不会创建指向该服务器的新连接，并且会立即删除现有连接。这相当于从主机组中删除服务器。
                         在内部，将服务器设置为OFFLINE_HARD状态相当于删除服务器
    * weight – 服务器相对于其他权重的权重越大，从主机组中选择服务器的概率越高。ProxySQL默认负载平衡算法是随机加权的
    * compression – 如果值为1，则到该服务器的新连接将使用压缩。请注意，前端和后端连接不需要同时使用压缩或不使用压缩。
                     无论后端连接是否使用压缩，每个前端连接都可以使用或不使用压缩
    * max_connections – ProxySQL将打开到此后端服务器的最大连接数。即使此服务器的权重最高，但一旦达到此限制，也不会打开与它的新连接。
                        请确保后端配置了正确的max_connections值，以避免ProxySQL试图超出该限制。
                        此外，ProxySQL的主要功能之一是多路复用（能够将同一后端连接用于多个前端连接）：如果有效，每个后端的最大连接数可以配置为非常小的值。
    * max_replication_lag – 如果大于0，ProxySQL将定期监视复制延迟，如果超过配置的阈值，它将暂时避开主机，直到复制赶上
    * use_ssl – 如果设置为1，到后端的连接将使用ssl。请注意，前端和后端连接不需要同时使用TLS或不使用TLS。
                    无论后端连接是否使用TLS，每个前端连接都可以使用或不使用TLS
    * max_latency_ms – 定期监控ping时间。如果主机的ping时间大于max_latency_ms，则会将其从连接池中排除（尽管服务器保持在线）
    * comment –可用于用户定义的任何用途的文本字段。可以是主机存储内容的描述、主机何时被添加或禁用的提醒，或者是由某个外部脚本处理的JSON。

#### mysql_replication_hostgroups

    表mysql_replication_hostgroups定义了用于传统主/从异步或半同步复制的复制hostgroups。如果使用Group Replication/InnoDB Cluster或Galera/Percona XtraDB Cluster进行复制，则应使用mysql_group_replication_hostgroups或mysql_galera_hostgroups（版本2.x中提供）。

    Admin> SHOW CREATE TABLE mysql_replication_hostgroups\G
    *************************** 1. row ***************************
           table: mysql_replication_hostgroups
    Create Table: CREATE TABLE mysql_replication_hostgroups (
        writer_hostgroup INT CHECK (writer_hostgroup>=0) NOT NULL PRIMARY KEY,
        reader_hostgroup INT NOT NULL CHECK (reader_hostgroup<>writer_hostgroup AND reader_hostgroup>0),
        check_type VARCHAR CHECK (LOWER(check_type) IN ('read_only','innodb_read_only','super_read_only','read_only|innodb_read_only','read_only&innodb_read_only')) NOT NULL DEFAULT 'read_only',
        comment VARCHAR,
        UNIQUE (reader_hostgroup))
    1 row in set (0.00 sec)

    mysql_replication_hostgroups中的每一行表示一对writer_hostgroup和reader_hostgroup。

    ProxySQL将为指定主机组中的所有服务器监视check_type中指定的变量，并根据该变量的值（或对2个变量的二进制操作），将服务器分配给writer或reader hostgroups。

    字段注释可用于存储任意数据。

    字段具有以下语义：
    writer_hostgroup – 配置writer的主机组。具有返回0的只读检查的节点将被分配到此主机组。
    reader_hostgroup – 配置reader的主机组。假设已定义查询规则或单独的只读用户将流量路由到此主机组，则应将读取流量发送到此主机组。具有返回1的
    check_type – 执行只读检查时检查的MySQL变量，以及可选的逻辑二进制操作。只读是默认设置。也可以使用innodb_read_only和super_read_only。
                 在引入AWS Aurora的本机支持之前，应使用innodb_read_only。可以组合对read_only和innodb_read_only的检查
    comment - 可用于用户定义的任何用途的文本字段。可以是集群存储内容的描述、主机组何时被添加或禁用的提醒，或者是由某个检查器脚本处理的JSON。

#### mysql_group_replication_hostgroups

    表mysql_group_replication_hostgroups定义了用于Oracle Group Replication/InnoDB Cluster的主机组

    Admin> show create table mysql_group_replication_hostgroups\G
    *************************** 1. row ***************************
           table: mysql_group_replication_hostgroups
    Create Table: CREATE TABLE mysql_group_replication_hostgroups (
        writer_hostgroup INT CHECK (writer_hostgroup>=0) NOT NULL PRIMARY KEY,
        backup_writer_hostgroup INT CHECK (backup_writer_hostgroup>=0 AND backup_writer_hostgroup<>writer_hostgroup) NOT NULL,
        reader_hostgroup INT NOT NULL CHECK (reader_hostgroup<>writer_hostgroup AND backup_writer_hostgroup<>reader_hostgroup AND reader_hostgroup>0),
        offline_hostgroup INT NOT NULL CHECK (offline_hostgroup<>writer_hostgroup AND offline_hostgroup<>reader_hostgroup AND backup_writer_hostgroup<>offline_hostgroup AND offline_hostgroup>=0),
        active INT CHECK (active IN (0,1)) NOT NULL DEFAULT 1,
        max_writers INT NOT NULL CHECK (max_writers >= 0) DEFAULT 1,
        writer_is_also_reader INT CHECK (writer_is_also_reader IN (0,1,2)) NOT NULL DEFAULT 0,
        max_transactions_behind INT CHECK (max_transactions_behind>=0) NOT NULL DEFAULT 0,
        comment VARCHAR,
        UNIQUE (reader_hostgroup),
        UNIQUE (offline_hostgroup),
        UNIQUE (backup_writer_hostgroup))
    1 row in set (0.00 sec)

    字段具有以下语义：
    * writer_hostgroup - 默认情况下，所有通信都将发送到的主机组。MySQL中read_only=0的节点将被分配到此主机组。
    * backup_writer_hostgroup - 如果群集有多个read_only=0的节点超过了max_writer，则ProxySQL会将其他节点（超过max_writes）放入backup_writer_hostgroup。
    * reader_hostgroup - 应将读取流量发送到的主机组，应定义查询规则或单独的只读用户以将流量路由到此主机组。read_only=1的节点将被分配到此主机组。
    * offline_hostgroup - 当ProxySQL的监视确定某个节点处于OFFLINE状态或不正常时，它将被放入offline_hostgroup。
    * active - 启用时，ProxySQL将监视主机组并在适当的主机组之间移动节点。
    * max_writers - 此值确定writer_hostgroup中应允许的最大节点数，超过此值的节点将放入backup_writer_hostgroup
    * writer_is_also_reader - 确定是否应将节点添加到reader_hostgroup以及writer_hostgroup。特殊值writer_is_also_reader=2表示只有backup_writer_hostgroup中的节点也在reader_hostgroup中，不包括writer_hostgroup中的节点
    * max_transactions_behind - 确定在避开节点以防止过时读取之前，ProxySQL应允许的写入程序后面的最大事务数（这是通过查询MySQL中sys.gr_member_routing_candidate_status表的transactions_behind字段确定的）。
    * comment - 可用于用户定义的任何用途的文本字段。可以是集群存储内容的描述、主机组何时被添加或禁用的提醒，或者是由某个检查器脚本处理的JSON。

    ProxySQL还提供了几个关于组复制集群监控的配置变量，可以在mysql监控变量文档中查阅这些配置变量。

#### mysql_galera_hostgroups

    mysql_galera_hostgroups表定义了用于Galera Cluster/Percona XtraDB Cluster的主机组。
    mysql_galera_hostgroups表中的每一行表示一个集群，而hostgroups是该集群的一部分。

    表定义如下所示：
    Admin> show create table mysql_galera_hostgroups\G
    *************************** 1. row ***************************
           table: mysql_galera_hostgroups
    Create Table: CREATE TABLE mysql_galera_hostgroups (
        writer_hostgroup INT CHECK (writer_hostgroup>=0) NOT NULL PRIMARY KEY,
        backup_writer_hostgroup INT CHECK (backup_writer_hostgroup>=0 AND backup_writer_hostgroup<>writer_hostgroup) NOT NULL,
        reader_hostgroup INT NOT NULL CHECK (reader_hostgroup<>writer_hostgroup AND backup_writer_hostgroup<>reader_hostgroup AND reader_hostgroup>0),
        offline_hostgroup INT NOT NULL CHECK (offline_hostgroup<>writer_hostgroup AND offline_hostgroup<>reader_hostgroup AND backup_writer_hostgroup<>offline_hostgroup AND offline_hostgroup>=0),
        active INT CHECK (active IN (0,1)) NOT NULL DEFAULT 1,
        max_writers INT NOT NULL CHECK (max_writers >= 0) DEFAULT 1,
        writer_is_also_reader INT CHECK (writer_is_also_reader IN (0,1,2)) NOT NULL DEFAULT 0,
        max_transactions_behind INT CHECK (max_transactions_behind>=0) NOT NULL DEFAULT 0,
        comment VARCHAR,
        UNIQUE (reader_hostgroup),
        UNIQUE (offline_hostgroup),
        UNIQUE (backup_writer_hostgroup))
    1 row in set (0.00 sec)

    字段具有以下语义：
    * writer_hostgroup - 默认情况下，所有通信都将发送到的主机组。MySQL中read_only=0的节点将被分配到此主机组。
    * backup_writer_hostgroup - 如果群集有多个read_only=0的节点超过了max_writer，则ProxySQL会将其他节点（超过max_writes）放入backup_writer_hostgroup。
    * reader_hostgroup - 应将读取流量发送到的主机组，应定义查询规则或单独的只读用户以将流量路由到此主机组。read_only=1的节点将被分配到此主机组。
    * offline_hostgroup - 当ProxySQL的监视确定某个节点处于OFFLINE状态或不正常时，它将被放入offline_hostgroup。
    * active - 启用时，ProxySQL将监视主机组并在适当的主机组之间移动节点。
    * max_writers - 此值确定writer_hostgroup中应允许的最大节点数，超过此值的节点将放入backup_writer_hostgroup
    * writer_is_also_reader - 确定是否应将节点添加到reader_hostgroup以及writer_hostgroup。特殊值writer_is_also_reader=2表示只有backup_writer_hostgroup中的节点也在reader_hostgroup中，不包括writer_hostgroup中的节点
    * max_transactions_behind - 确定在避开节点以防止过时读取之前，ProxySQL应允许的写入程序后面的最大事务数（这是通过查询MySQL中sys.gr_member_routing_candidate_status表的transactions_behind字段确定的）。
    * comment - 可用于用户定义的任何用途的文本字段。可以是集群存储内容的描述、主机组何时被添加或禁用的提醒，或者是由某个检查器脚本处理的JSON。

#### mysql_users

    表mysql_users定义了客户端可以用来连接到ProxySQL，然后用来连接到后端的mysql用户。

    Admin> SHOW CREATE TABLE mysql_users\G
    *************************** 1. row ***************************
           table: mysql_users
    Create Table: CREATE TABLE mysql_users (
        username VARCHAR NOT NULL,
        password VARCHAR,
        active INT CHECK (active IN (0,1)) NOT NULL DEFAULT 1,
        use_ssl INT CHECK (use_ssl IN (0,1)) NOT NULL DEFAULT 0,
        default_hostgroup INT NOT NULL DEFAULT 0,
        default_schema VARCHAR,
        schema_locked INT CHECK (schema_locked IN (0,1)) NOT NULL DEFAULT 0,
        transaction_persistent INT CHECK (transaction_persistent IN (0,1)) NOT NULL DEFAULT 0,
        fast_forward INT CHECK (fast_forward IN (0,1)) NOT NULL DEFAULT 0,
        backend INT CHECK (backend IN (0,1)) NOT NULL DEFAULT 1,
        frontend INT CHECK (frontend IN (0,1)) NOT NULL DEFAULT 1,
        max_connections INT CHECK (max_connections >=0) NOT NULL DEFAULT 10000,
        comment VARCHAR NOT NULL DEFAULT '',
        PRIMARY KEY (username, backend),
        UNIQUE (username, frontend))
    1 row in set (0.00 sec)

    字段具有以下语义：
    * username, password – 连接到mysqld或ProxySQL实例的凭据。密码可以是明文或哈希形式。另请参见密码管理(https://proxysql.com/documentation/Password-management)
    * active – active=0的用户将在数据库中跟踪，但不会加载到内存中的数据结构中
    * use_ssl – 如果设置为1，则用户将被迫使用ssl证书进行身份验证。另请参见SSL支持
    * default_hostgroup – 如果此用户发送的查询没有匹配规则，则它生成的通信量将发送到指定的主机组
    * default_schema – 默认情况下连接应更改到的模式
    * schema_locked – 尚不支持（TODO:检查）
    * transaction_persistent – 如果为MySQL客户端连接到ProxySQL的用户（因此是"前端"用户，请参见下文）设置了此选项，
                               则在主机组中启动的事务将保留在该主机组中，而不考虑任何其他规则
    * fast_forward – 如果设置，它将绕过查询处理层（重写、缓存），直接通过查询传递到后端服务器。
    * frontend – 如果设置为1，则此（用户名、密码）对用于对ProxySQL实例进行身份验证
    * backend – 如果设置为1，则此（用户名、密码）对用于针对任何主机组对mysqld服务器进行身份验证
    * max_connections – 定义特定用户允许的最大前端连接数。
    * comment – 可用于用户定义的任何用途的文本字段。可以是集群存储内容的描述、主机组何时被添加或禁用的提醒，或者是由某个检查器脚本处理的JSON。

    注意，目前所有用户都需要将"frontend前端"和"backend后端"设置为1。ProxySQL的未来版本将分离前端和后端之间的增量。
    这样，前端将永远不会知道要直接连接到后端的凭据，强制所有连接都通过ProxySQL进行，从而提高系统的安全性。

    快进说明：
    它不需要不同的端口：全功能代理逻辑和"fast forward"逻辑在同一代码/模块中实现

    快进是在每个用户的基础上实现的：根据连接到ProxySQL的用户，fast forward快进是启用还是禁用的

    身份验证后启用快进算法：客户端仍对ProxySQL进行身份验证，并且当客户端开始发送流量时，ProxySQL将创建连接。
    这意味着在连接阶段仍会处理连接错误。

    快进不支持SSL

    如果使用压缩，则必须在两端启用压缩

    注意：mysql_users中的用户不应同时用于admin-admin_credentials和admin-stats_credentials

#### mysql_query_rules

    mysql_query_rules定义路由策略和属性。
    Admin> SHOW CREATE TABLE mysql_query_rules\G
    *************************** 1. row ***************************
           table: mysql_query_rules
    Create Table: CREATE TABLE mysql_query_rules (
        rule_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
        active INT CHECK (active IN (0,1)) NOT NULL DEFAULT 0,
        username VARCHAR,
        schemaname VARCHAR,
        flagIN INT CHECK (flagIN >= 0) NOT NULL DEFAULT 0,
        client_addr VARCHAR,
        proxy_addr VARCHAR,
        proxy_port INT,
        digest VARCHAR,
        match_digest VARCHAR,
        match_pattern VARCHAR,
        negate_match_pattern INT CHECK (negate_match_pattern IN (0,1)) NOT NULL DEFAULT 0,
        re_modifiers VARCHAR DEFAULT 'CASELESS',
        flagOUT INT CHECK (flagOUT >= 0),
        replace_pattern VARCHAR CHECK(CASE WHEN replace_pattern IS NULL THEN 1 WHEN replace_pattern IS NOT NULL AND match_pattern IS NOT NULL THEN 1 ELSE 0 END),
        destination_hostgroup INT DEFAULT NULL,
        cache_ttl INT CHECK(cache_ttl > 0),
        cache_empty_result INT CHECK (cache_empty_result IN (0,1)) DEFAULT NULL,
        reconnect INT CHECK (reconnect IN (0,1)) DEFAULT NULL,
        timeout INT UNSIGNED,
        retries INT CHECK (retries>=0 AND retries <=1000),
        delay INT UNSIGNED,
        next_query_flagIN INT UNSIGNED,
        mirror_flagOUT INT UNSIGNED,
        mirror_hostgroup INT UNSIGNED,
        error_msg VARCHAR,
        OK_msg VARCHAR,
        sticky_conn INT CHECK (sticky_conn IN (0,1)),
        multiplex INT CHECK (multiplex IN (0,1,2)),
        gtid_from_hostgroup INT UNSIGNED,
        log INT CHECK (log IN (0,1)),
        apply INT CHECK(apply IN (0,1)) NOT NULL DEFAULT 0,
        comment VARCHAR)
    1 row in set (0.00 sec)

    字段具有以下语义：

    rule_id – 规则的唯一id。规则按规则id顺序处理
    active – 查询处理模块将只考虑active=1的规则，并且只将活动规则加载到运行时。
    username – 与用户名匹配的筛选条件。如果为非NULL，则只有使用正确的用户名进行连接时，查询才会匹配
    schemaname – 匹配schemaname的筛选条件。如果非空，则只有当连接使用schemaname作为默认模式时，查询才会匹配（在mariadb/mysql中，schemaname相当于databasename）
    flagIN, flagOUT, apply – 这些允许我们创建一个接一个应用的"规则链"。输入标志值设置为0，开始时仅考虑flagIN=0的规则。当为特定查询找到匹配规则时，将计算flagOUT，如果不为NULL，则将使用flagOUT中的指定标志对查询进行标记。
                             如果flagOUT与flagIN不同，查询将退出当前链，并输入一个新的规则链，其中flagIN作为新的输入标志。如果flagOUT与flagIN匹配，则将根据具有所述flagIN的第一条规则重新计算查询。
                             直到不再有匹配规则，或将apply设置为1（这意味着这是最后一个要应用的规则）时，才会发生这种情况
    client_addr – 匹配来自特定源的流量
    proxy_addr – 匹配特定本地IP上的传入流量
    proxy_port – 匹配特定本地端口上的传入流量
    digest – 将查询与特定摘要相匹配，如stats_mysql_query_digest.digest返回的
    match_digest – 与查询摘要匹配的正则表达式。另请参见mysql-query_processor_regex
    match_pattern – 与查询文本匹配的正则表达式。另请参见mysql-query_processor_regex
    negate_match_pattern – 如果设置为1，则只有与查询文本不匹配的查询才会被视为匹配。这在正则表达式与match_pattern或match_digest匹配之前充当NOT运算符
    re_modifiers – 以逗号分隔的选项列表，用于修改RE引擎的行为。对于无大小写，匹配不区分大小写。对于全局，替换是全局的（替换所有匹配项，而不仅仅是第一个匹配项）。
                   对于向后兼容性，默认情况下仅启用无大小写。有关更多详细信息，请参见mysql-query_processor_regex。
    replace_pattern – 这是用于替换匹配模式的模式。它是使用RE2::Replace完成的，因此值得一看在线文档：
                        https://github.com/google/re2/blob/master/re2/re2.h#L378.
                        请注意，这是可选的，如果缺少此选项，查询处理器将只缓存、路由或设置其他参数，而不进行重写。
    destination_hostgroup – 将匹配的查询路由到此hostgroup。除非有一个已启动的事务，并且登录用户将transaction_persistent标志设置为1（请参阅mysql_users），否则会发生这种情况。
    cache_ttl – 缓存查询结果的毫秒数。注意：在ProxySQL 1.1缓存中，ttl以秒为单位
    cache_empty_result – 控制是否缓存没有行的结果集
    reconnect – 未使用功能
    timeout – 执行匹配或重写查询的最大超时（毫秒）。如果查询的运行时间超过特定阈值，则该查询将自动终止。如果未指定超时，则应用全局变量mysql-default_query_timeout
    retries – 如果在执行查询期间检测到故障，则需要重新执行查询的最大次数。如果未指定重试次数，则应用全局变量mysql-query_retries_on_failure
    delay – 延迟查询执行的毫秒数。这本质上是一种限制机制和QoS，允许优先考虑某些查询而不是其他查询。该值被添加到mysql-default_query_delay全局变量中，该变量适用于所有查询。ProxySQL的未来版本将提供更高级的节流机制。
    mirror_flagOUT 和 mirror_hostgroup – 与镜像相关的设置
    error_msg – 查询将被阻止，指定的error_msg将返回给客户端
    OK_msg – 对于使用已定义规则的查询，将返回指定的消息
    sticky_conn – 尚未实施
    multiplex – 如果为0，则多路复用将被禁用。
                如果为1，如果没有任何其他条件（如用户变量或事务）阻止此操作，则可以重新启用多路复用。
                如果为2，则不仅对当前查询禁用多路复用。请参阅wiki默认值为NULL，因此不修改多路复用策略
    gtid_from_hostgroup –  定义应将哪个主机组用作gtid一致读取的先导（通常是replication主机组对中定义的WRITER主机组）
    log – 此列可以有三个值:
                1–匹配的查询将记录到事件日志中；
                0–匹配的查询不会记录到事件日志中；
                NULL–匹配的查询日志属性将保留以前匹配的值。如果在应用规则时（apply=1），或在处理所有查询规则后，其日志属性设置为1，则执行的查询将记录到事件日志中

    apply – 当设置为1时，在匹配和处理此规则后，将不会计算进一步的查询（注意：mysql_query_rules_fast_routing规则之后将不会计算）
    comment – 自由格式文本字段，可用于查询规则的描述性注释

#### mysql_query_rules_fast_routing

    mysql_query_rules_fast_routing表是mysql_query_rules的一个扩展，之后将对快速路由策略和属性进行评估（仅在ProxySQL 1.4.7+中可用）

    Admin> SHOW CREATE TABLE mysql_query_rules_fast_routing\G
    *************************** 1. row ***************************
           table: mysql_query_rules_fast_routing
    Create Table: CREATE TABLE mysql_query_rules_fast_routing (
        username VARCHAR NOT NULL,
        schemaname VARCHAR NOT NULL,
        flagIN INT NOT NULL DEFAULT 0,
        destination_hostgroup INT CHECK (destination_hostgroup >= 0) NOT NULL,
        comment VARCHAR NOT NULL,
        PRIMARY KEY (username, schemaname, flagIN) )
    1 row in set (0,00 sec)

    字段具有以下语义：
    * username – 筛选条件匹配username，只有使用正确的用户名建立连接时，查询才会匹配
    * schemaname – 过滤条件匹配schemaname，只有当连接使用schemaname作为默认模式时，查询才会匹配（在mariadb/mysql schemaname中，这相当于databasename）
    * flagIN – 以与mysql_query_rules中的flagIN相同的方式进行计算，并与mysql_query_rules中指定的flagout/apply相关联
    * destination_hostgroup - 将匹配的查询路由到此hostgroup。除非有一个已启动的事务，并且登录用户将transaction_persistent标志设置为1，否则会发生这种情况（请参见mysql_users）
    * comment - 自由格式文本字段，可用于查询规则的描述性注释

#### global_variables

    表global_variables定义了全局变量。这是一个简单得多的表，本质上是一个键值存储。这些是ProxySQL使用的全局变量，对于调整其行为非常有用。

    全局变量根据其前缀分组在类中。
    目前有两类全局变量，尽管路线图中有更多的类：

    * 前缀为admin-变量与admin模块相关，允许调整admin接口，例如更改admin接口（admin-mysql_ifaces）或admin凭据（admin-admin_credentials）
    * 前缀为mysql-的变量与模块相关，并允许调整mysql相关功能。具体而言，它们包括与以下相关的变量的调整：

        * MySQL流量的处理
        * 监视器操作（进一步加上mysql-monitor前缀）
        * 查询缓存

    有关特定变量的更多信息，请参阅关于全局变量(https://proxysql.com/documentation/Global-variables)的专用部分

    Admin> SHOW CREATE TABLE global_variables\G
    *************************** 1. row ***************************
           table: global_variables
    Create Table: CREATE TABLE global_variables (
        variable_name VARCHAR NOT NULL PRIMARY KEY,
        variable_value VARCHAR NOT NULL)
    1 row in set (0.00 sec)

    以下是编写时global_variables的外观示例（版本1.2.4），供参考：

    Admin> SELECT * FROM global_variables ORDER BY variable_name;
    +-----------------------------------------------------+------------------------+
    | variable_name                                       | variable_value         |
    +-----------------------------------------------------+------------------------+
    | admin-admin_credentials                             | admin:admin            |
    | admin-checksum_mysql_query_rules                    | true                   |
    | admin-checksum_mysql_servers                        | true                   |
    | admin-checksum_mysql_users                          | true                   |
    | admin-cluster_check_interval_ms                     | 1000                   |
    | admin-cluster_check_status_frequency                | 10                     |
    | admin-cluster_mysql_query_rules_diffs_before_sync   | 3                      |
    | admin-cluster_mysql_query_rules_save_to_disk        | true                   |
    | admin-cluster_mysql_servers_diffs_before_sync       | 3                      |
    | admin-cluster_mysql_servers_save_to_disk            | true                   |
    | admin-cluster_mysql_users_diffs_before_sync         | 3                      |
    | admin-cluster_mysql_users_save_to_disk              | true                   |
    | admin-cluster_password                              |                        |
    | admin-cluster_proxysql_servers_diffs_before_sync    | 3                      |
    | admin-cluster_proxysql_servers_save_to_disk         | true                   |
    | admin-cluster_username                              |                        |
    | admin-hash_passwords                                | true                   |
    | admin-mysql_ifaces                                  | 0.0.0.0:6032           |
    | admin-read_only                                     | false                  |
    | admin-refresh_interval                              | 2000                   |
    | admin-stats_credentials                             | stats:stats            |
    | admin-stats_mysql_connection_pool                   | 60                     |
    | admin-stats_mysql_connections                       | 60                     |
    | admin-stats_mysql_query_cache                       | 60                     |
    | admin-stats_system_cpu                              | 60                     |
    | admin-stats_system_memory                           | 60                     |
    | admin-telnet_admin_ifaces                           | (null)                 |
    | admin-telnet_stats_ifaces                           | (null)                 |
    | admin-version                                       | v2.0.0-rc1-17-g832aa48 |
    | admin-web_enabled                                   | false                  |
    | admin-web_port                                      | 6080                   |
    | mysql-autocommit_false_is_transaction               | false                  |
    | mysql-autocommit_false_not_reusable                 | false                  |
    | mysql-binlog_reader_connect_retry_msec              | 3000                   |
    | mysql-client_found_rows                             | true                   |
    | mysql-client_multi_statements                       | true                   |
    | mysql-commands_stats                                | true                   |
    | mysql-connect_retries_delay                         | 1                      |
    | mysql-connect_retries_on_failure                    | 10                     |
    | mysql-connect_timeout_server                        | 3000                   |
    | mysql-connect_timeout_server_max                    | 10000                  |
    | mysql-connection_delay_multiplex_ms                 | 0                      |
    | mysql-connection_max_age_ms                         | 0                      |
    | mysql-connpoll_reset_queue_length                   | 50                     |
    | mysql-default_charset                               | utf8                   |
    | mysql-default_max_latency_ms                        | 1000                   |
    | mysql-default_query_delay                           | 0                      |
    | mysql-default_query_timeout                         | 36000000               |
    | mysql-default_reconnect                             | true                   |
    | mysql-default_schema                                | information_schema     |
    | mysql-default_sql_mode                              |                        |
    | mysql-default_time_zone                             | SYSTEM                 |
    | mysql-enforce_autocommit_on_reads                   | false                  |
    | mysql-eventslog_filename                            |                        |
    | mysql-eventslog_filesize                            | 104857600              |
    | mysql-forward_autocommit                            | false                  |
    | mysql-free_connections_pct                          | 10                     |
    | mysql-have_compress                                 | true                   |
    | mysql-have_ssl                                      | false                  |
    | mysql-hostgroup_manager_verbose                     | 1                      |
    | mysql-init_connect                                  |                        |
    | mysql-interfaces                                    | 0.0.0.0:6033           |
    | mysql-kill_backend_connection_when_disconnect       | true                   |
    | mysql-long_query_time                               | 1000                   |
    | mysql-max_allowed_packet                            | 4194304                |
    | mysql-max_connections                               | 2048                   |
    | mysql-max_stmts_cache                               | 10000                  |
    | mysql-max_stmts_per_connection                      | 20                     |
    | mysql-max_transaction_time                          | 14400000               |
    | mysql-mirror_max_concurrency                        | 16                     |
    | mysql-mirror_max_queue_length                       | 32000                  |
    | mysql-monitor_connect_interval                      | 60000                  |
    | mysql-monitor_connect_timeout                       | 600                    |
    | mysql-monitor_enabled                               | true                   |
    | mysql-monitor_galera_healthcheck_interval           | 5000                   |
    | mysql-monitor_galera_healthcheck_timeout            | 800                    |
    | mysql-monitor_groupreplication_healthcheck_interval | 5000                   |
    | mysql-monitor_groupreplication_healthcheck_timeout  | 800                    |
    | mysql-monitor_history                               | 600000                 |
    | mysql-monitor_password                              | monitor                |
    | mysql-monitor_ping_interval                         | 10000                  |
    | mysql-monitor_ping_max_failures                     | 3                      |
    | mysql-monitor_ping_timeout                          | 1000                   |
    | mysql-monitor_query_interval                        | 60000                  |
    | mysql-monitor_query_timeout                         | 100                    |
    | mysql-monitor_read_only_interval                    | 1500                   |
    | mysql-monitor_read_only_max_timeout_count           | 3                      |
    | mysql-monitor_read_only_timeout                     | 500                    |
    | mysql-monitor_replication_lag_interval              | 10000                  |
    | mysql-monitor_replication_lag_timeout               | 1000                   |
    | mysql-monitor_replication_lag_use_percona_heartbeat |                        |
    | mysql-monitor_slave_lag_when_null                   | 60                     |
    | mysql-monitor_threads_max                           | 128                    |
    | mysql-monitor_threads_min                           | 8                      |
    | mysql-monitor_threads_queue_maxsize                 | 128                    |
    | mysql-monitor_username                              | monitor                |
    | mysql-monitor_wait_timeout                          | true                   |
    | mysql-monitor_writer_is_also_reader                 | true                   |
    | mysql-multiplexing                                  | true                   |
    | mysql-ping_interval_server_msec                     | 120000                 |
    | mysql-ping_timeout_server                           | 500                    |
    | mysql-poll_timeout                                  | 2000                   |
    | mysql-poll_timeout_on_failure                       | 100                    |
    | mysql-query_cache_size_MB                           | 256                    |
    | mysql-query_cache_stores_empty_result               | true                   |
    | mysql-query_digests                                 | true                   |
    | mysql-query_digests_lowercase                       | false                  |
    | mysql-query_digests_max_digest_length               | 2048                   |
    | mysql-query_digests_max_query_length                | 65000                  |
    | mysql-query_processor_iterations                    | 0                      |
    | mysql-query_processor_regex                         | 1                      |
    | mysql-query_retries_on_failure                      | 1                      |
    | mysql-reset_connection_algorithm                    | 2                      |
    | mysql-server_capabilities                           | 45578                  |
    | mysql-server_version                                | 5.5.30                 |
    | mysql-servers_stats                                 | true                   |
    | mysql-session_idle_ms                               | 1000                   |
    | mysql-session_idle_show_processlist                 | true                   |
    | mysql-sessions_sort                                 | true                   |
    | mysql-shun_on_failures                              | 5                      |
    | mysql-shun_recovery_time_sec                        | 10                     |
    | mysql-ssl_p2s_ca                                    |                        |
    | mysql-ssl_p2s_cert                                  |                        |
    | mysql-ssl_p2s_cipher                                |                        |
    | mysql-ssl_p2s_key                                   |                        |
    | mysql-stacksize                                     | 1048576                |
    | mysql-stats_time_backend_query                      | false                  |
    | mysql-stats_time_query_processor                    | false                  |
    | mysql-threads                                       | 4                      |
    | mysql-threshold_query_length                        | 524288                 |
    | mysql-threshold_resultset_size                      | 4194304                |
    | mysql-throttle_connections_per_sec_to_hostgroup     | 1000000                |
    | mysql-throttle_max_bytes_per_second_to_client       | 2147483647             |
    | mysql-throttle_ratio_server_to_client               | 0                      |
    | mysql-verbose_query_error                           | false                  |
    | mysql-wait_timeout                                  | 28800000               |
    +-----------------------------------------------------+------------------------+
    136 rows in set (0.01 sec)

#### scheduler

    表调度器定义要定期执行的作业。
    Admin> SHOW CREATE TABLE scheduler\G
    *************************** 1. row ***************************
           table: scheduler
    Create Table: CREATE TABLE scheduler (
        id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
        active INT CHECK (active IN (0,1)) NOT NULL DEFAULT 1,
        interval_ms INTEGER CHECK (interval_ms>=100 AND interval_ms<=100000000) NOT NULL,
        filename VARCHAR NOT NULL,
        arg1 VARCHAR,
        arg2 VARCHAR,
        arg3 VARCHAR,
        arg4 VARCHAR,
        arg5 VARCHAR,
        comment VARCHAR NOT NULL DEFAULT '')
    1 row in set (0.00 sec)

    有关调度程序的更多详细信息，请参见此处(https://proxysql.com/documentation/Scheduler)

#### restapi_routes

    表restapi_routes定义了远程客户端可以使用REST API端点调用的端点，该端点使用HTTP触发ProxySQL执行任务。

    下表定义如下：
    mysql> SHOW CREATE TABLE restapi_routes\G
    *************************** 1. row ***************************
    table: restapi_routes
    Create Table: CREATE TABLE restapi_routes (
    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    active INT CHECK (active IN (0,1)) NOT NULL DEFAULT 1,
    timeout_ms INTEGER CHECK (timeout_ms>=100 AND timeout_ms<=100000000) NOT NULL,
    method VARCHAR NOT NULL CHECK (UPPER(method) IN ('GET','POST')),
    uri VARCHAR NOT NULL,
    script VARCHAR NOT NULL,
    comment VARCHAR NOT NULL DEFAULT '')
    1 row in set (0,03 sec)

    该表定义了：
    id: 端点的唯一标识符
    active: RESTAPI端点可以是活动的，也可以不是活动的。默认情况下，端点处于活动状态，可以将其设置为0而无需删除
    timeout_ms: 这定义了到达该端点时proxysql将调用的作业的最大执行时间
    method: 可以使用GET或POST方法调用restapi端点。这定义了必须使用的方法
    uri: 定义端点的uri（统一资源标识符）
    script: 这是proxysql将在指定端点执行的脚本（或其他可执行文件）
    comment: 可用于用户定义的任何用途的文本字段，例如用于描述端点

#### mysql_collations

    以下是mysql_collations表的表定义：

    Admin> show create table mysql_collations\G
    *************************** 1. row ***************************
           table: mysql_collations
    Create Table: CREATE TABLE mysql_collations (
        Id INTEGER NOT NULL PRIMARY KEY,
        Collation VARCHAR NOT NULL,
        Charset VARCHAR NOT NULL,
        `Default` VARCHAR NOT NULL)
    1 row in set (0.01 sec)

    表mysql_collations表示ProxySQL支持的所有已知和可用（字符集、排序规则）对。

    列Id表示MySQL本身中定义的排序规则的数值。

    列“Default”定义给定排序规则是否为其所属排序规则的默认排序规则。

    请注意，MySQL更改给定字符集的默认排序规则时，ProxySQL可能使用的默认排序规则与后端中指定的不同。

    例如，在MySQL 5.7和ProxySQL中，utf8mb4的默认排序规则是utf8mb4_general_ci，而在MySQL 8.0中，默认排序规则是utf8mb4_0900_ai_ci。

    如果客户端在连接阶段或以后使用集合名称指定排序规则SET NAMES ... COLLATE ...，proxysql将跟踪并使用正确的排序规则。

    原则上，ProxySQL将验证传入连接是否具有受支持的字符集和排序规则，并确保池后端连接在使用它们之前切换到正确的字符集和排序规则。

# Runtime表

    上面列出的所有配置表都有一个匹配的运行时表：
    runtime_global_variables : 全局变量的运行时版本
    runtime_mysql_replication_hostgroups : mysql_replication_hostgroups运行时版本
    runtime_mysql_galera_hostgroups : mysql_replication_hostgroups运行时版本
    runtime_mysql_group_replication_hostgroups : mysql_replication_hostgroups运行时版本
    runtime_mysql_query_rules : mysql_query_rules运行时版本
    runtime_mysql_query_rules_fast_routing : mysql_query_rules_fast_routing运行时版本
    runtime_mysql_servers : mysql_servers运行时版本
    runtime_mysql_users : mysql_users运行时版本
    runtime_proxysql_servers : proxysql_servers运行时版本
    runtime_scheduler : scheduler运行时版本

### 关于main schema的一点注记

    请注意，如果内存中表（main数据库）的内容未保存在磁盘数据库中，则在重新启动ProxySQL时，这些表的所有内容都将丢失。

## Debug 配置

#### debug_levels

    debug_levels表定义了一系列详细级别，在"debug"模式下编译时，可以为ProxySQL启用这些详细级别。

    Admin> SHOW CREATE TABLE debug_levels\G
    *************************** 1. row ***************************
           table: debug_levels
    Create Table: CREATE TABLE debug_levels (
        module VARCHAR NOT NULL PRIMARY KEY,
        verbosity INT NOT NULL DEFAULT 0)
    1 row in set (0.00 sec)

    以下示例显示了编写时"debug_levels"的外观（v2.3.2），以供参考：
    Admin> SELECT * FROM debug_levels;\G
    +-----------------------------+-----------+
    | module                      | verbosity |
    +-----------------------------+-----------+
    | debug_generic               | 0         |
    | debug_net                   | 0         |
    | debug_pkt_array             | 0         |
    | debug_poll                  | 0         |
    | debug_mysql_com             | 0         |
    | debug_mysql_server          | 0         |
    | debug_mysql_connection      | 0         |
    | debug_mysql_connpool        | 0         |
    | debug_mysql_rw_split        | 0         |
    | debug_mysql_auth            | 0         |
    | debug_mysql_protocol        | 0         |
    | debug_mysql_query_processor | 0         |
    | debug_memory                | 0         |
    | debug_admin                 | 0         |
    | debug_sqlite                | 0         |
    | debug_ipc                   | 0         |
    | debug_query_cache           | 0         |
    | debug_query_statistics      | 0         |
    +-----------------------------+-----------+
    18 rows in set (0.00 sec)

    要更改这些值，需要：
    1. 为任何变量设置一个新值，例如：UPDATE debug_levels SET verbosity=9 WHERE module='debug_mysql_com'
    2. 加载新配置：LOAD DEBUG TO RUNTIME
    3. 通过admin-debug变量启用调试，即：SET admin-debug='true'；LOAD ADMIN VARIABLES TO RUNTIME;

#### disk 数据库

    "disk"数据库具有与"main"数据库完全相同的表（减去runtime_ 表），具有相同的语义。唯一的主要区别是这些表存储在磁盘上，而不是存储在内存中。
    每当重新启动ProxySQL时，内存中的"main"数据库将从此数据库开始填充。

    请注意，如果内存中表（main数据库）的内容未保存在磁盘数据库中，   则在重新启动ProxySQL时，这些表的所有内容都将丢失。

    配置mysql group replication需要将视图添加到mysql实例sys

        USE sys;

        DELIMITER $$

        CREATE FUNCTION IFZERO(a INT, b INT)
        RETURNS INT
        DETERMINISTIC
        RETURN IF(a = 0, b, a)$$

        CREATE FUNCTION LOCATE2(needle TEXT(10000), haystack TEXT(10000), offset INT)
        RETURNS INT
        DETERMINISTIC
        RETURN IFZERO(LOCATE(needle, haystack, offset), LENGTH(haystack) + 1)$$

        CREATE FUNCTION GTID_NORMALIZE(g TEXT(10000))
        RETURNS TEXT(10000)
        DETERMINISTIC
        RETURN GTID_SUBTRACT(g, '')$$

        CREATE FUNCTION GTID_COUNT(gtid_set TEXT(10000))
        RETURNS INT
        DETERMINISTIC
        BEGIN
          DECLARE result BIGINT DEFAULT 0;
          DECLARE colon_pos INT;
          DECLARE next_dash_pos INT;
          DECLARE next_colon_pos INT;
          DECLARE next_comma_pos INT;
          SET gtid_set = GTID_NORMALIZE(gtid_set);
          SET colon_pos = LOCATE2(':', gtid_set, 1);
          WHILE colon_pos != LENGTH(gtid_set) + 1 DO
             SET next_dash_pos = LOCATE2('-', gtid_set, colon_pos + 1);
             SET next_colon_pos = LOCATE2(':', gtid_set, colon_pos + 1);
             SET next_comma_pos = LOCATE2(',', gtid_set, colon_pos + 1);
             IF next_dash_pos < next_colon_pos AND next_dash_pos < next_comma_pos THEN
               SET result = result +
                 SUBSTR(gtid_set, next_dash_pos + 1,
                        LEAST(next_colon_pos, next_comma_pos) - (next_dash_pos + 1)) -
                 SUBSTR(gtid_set, colon_pos + 1, next_dash_pos - (colon_pos + 1)) + 1;
             ELSE
               SET result = result + 1;
             END IF;
             SET colon_pos = next_colon_pos;
          END WHILE;
          RETURN result;
        END$$

        CREATE FUNCTION gr_applier_queue_length()
        RETURNS INT
        DETERMINISTIC
        BEGIN
          RETURN (SELECT sys.gtid_count( GTID_SUBTRACT( (SELECT
        Received_transaction_set FROM performance_schema.replication_connection_status
        WHERE Channel_name = 'group_replication_applier' ), (SELECT
        @@global.GTID_EXECUTED) )));
        END$$

        CREATE FUNCTION gr_member_in_primary_partition()
        RETURNS VARCHAR(3)
        DETERMINISTIC
        BEGIN
          RETURN (SELECT IF( MEMBER_STATE='ONLINE' AND ((SELECT COUNT(*) FROM
        performance_schema.replication_group_members WHERE MEMBER_STATE != 'ONLINE') >=
        ((SELECT COUNT(*) FROM performance_schema.replication_group_members)/2) = 0),
        'YES', 'NO' ) FROM performance_schema.replication_group_members JOIN
        performance_schema.replication_group_member_stats USING(member_id));
        END$$

        CREATE VIEW gr_member_routing_candidate_status AS SELECT
        sys.gr_member_in_primary_partition() as viable_candidate,
        IF( (SELECT (SELECT GROUP_CONCAT(variable_value) FROM
        performance_schema.global_variables WHERE variable_name IN ('read_only',
        'super_read_only')) != 'OFF,OFF'), 'YES', 'NO') as read_only,
        sys.gr_applier_queue_length() as transactions_behind, Count_Transactions_in_queue as 'transactions_to_cert' from performance_schema.replication_group_member_stats;$$

        DELIMITER ;

    然后将 grant select on sys.* to monitoring_user